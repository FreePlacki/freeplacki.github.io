<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

    <title>Mandelbrot set in CSS</title>

    <link rel="stylesheet" href="../../custom-highlight.css" />
    <link rel="stylesheet" href="../../styles.css" />
    <link rel="stylesheet" href="../../post.css" />
</head>

<body>
        <nav id="TOC">
        <h2>Mandelbrot set in CSS</h2>
        <ul>
        <li><a href="#what" id="toc-what">What?</a></li>
        <li><a href="#why" id="toc-why">Why?</a></li>
        <li><a href="#laying-the-foundation-variables"
        id="toc-laying-the-foundation-variables">Laying the foundation,
        variables</a></li>
        <li><a href="#the-first-iteration"
        id="toc-the-first-iteration">The first iteration</a></li>
        <li><a href="#fixing-the-problems"
        id="toc-fixing-the-problems">Fixing the problems</a></li>
        <li><a href="#more-iterations" id="toc-more-iterations">More
        iterations</a></li>
        <li><a href="#zooming-in" id="toc-zooming-in">Zooming
        in</a></li>
        <li><a href="#the-end" id="toc-the-end">The end</a></li>
        </ul>
    </nav>
    
    <h2 id="what">What?</h2>
    <p>If you somehow don’t know what the <a
    href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot
    set</a> is, here is a quick introduction. It’s defined as the set of
    all numbers
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">c \in \mathbb{C}</annotation></semantics></math>
    for which the function
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f(z) = z^2 + c</annotation></semantics></math>
    doesn’t diverge to infinity when iterated starting at
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=0</annotation></semantics></math>.</p>
    <p>By mapping the values of
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
    to cartesian coordinates (meaning for example
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>3</mn><mo>+</mo><mn>4</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">c=3+4i</annotation></semantics></math>
    gets mapped to the point
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(3, 4)</annotation></semantics></math>)
    we can produce some <a
    href="https://en.wikipedia.org/wiki/Mandelbrot_set#/media/File:Mandel_zoom_00_mandelbrot_set.jpg">cool
    images</a>. You choose a color for the points that belong to the set
    and for others you pick the colors based on how fast they diverge
    (how many iterations were needed before the value crossed a certain
    threshold).</p>
    <p>You can check out the final product <a
    href="https://freeplacki.github.io/cssbrot">here</a> along with the
    source code <a href="https://github.com/FreePlacki/cssbrot">here</a>
    (NOTE: if it doesn’t work try disabling darkreader or any similar
    extension).</p>
    <div class="sidenote">
    <p>Try moving your cursor over it.</p>
    </div>
    <h2 id="why">Why?</h2>
    <p>You can generate such images with a few lines of pretty much any
    <em>reasonable</em> programming language. Doing it in pure HTML+CSS
    presents some challenges. As we all know, CSS is clearly <a
    href="https://stackoverflow.com/a/26445990">not Turing complete</a>
    as there is no way to have infinite loops, so if it was then we
    would have a contradiction with <a
    href="https://en.wikipedia.org/wiki/Halting_problem">the Halting
    Problem</a>.</p>
    <blockquote>
    <p>Actually… it is. <a
    href="http://eli.fox-epste.in/rule110-full.html">Look</a> I
    implemented <a href="https://en.wikipedia.org/wiki/Rule_110">Rule
    110</a>.</p>
    <blockquote>
    <p><a
    href="https://accodeing.com/blog/2015/duty-calls-css3-is-not-proven-to-be-turing-complete">Nope</a>.
    Using your approach the number of CSS rules would scale with the
    input AND it requires constant human interaction to function.</p>
    <blockquote>
    <p>Ok, <a
    href="https://accodeing.com/blog/2015/css3-proven-to-be-turing-complete">maybe
    not</a> but still it requires the user to constantly press keys so
    you might as well just <a
    href="https://stackoverflow.com/a/51408598">write the instructions
    for the human in natural language</a>.</p>
    </blockquote>
    </blockquote>
    </blockquote>
    <p>…</p>
    <p>It’s not that simple and you’re welcome to do your own research.
    What is certain though, is that modern CSS has features (that we
    will explore in a second) that allow you to do <a
    href="https://mooninaut.github.io/css-is-turing-complete/">cool
    shit</a> and <a href="https://lab.avl.la/css-calculations/">perform
    arithmetic</a>.</p>
    <h2 id="laying-the-foundation-variables">Laying the foundation,
    variables</h2>
    <p>As far as I’m aware there is no way to draw on the html canvas
    with just CSS and we are gonna need something to represent our
    drawing, so we’ll use individual <code>div</code>s to represent the
    pixels. Let’s go for a
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mo>×</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">20\times20</annotation></semantics></math>
    image for a total of
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>400</mn><annotation encoding="application/x-tex">400</annotation></semantics></math>
    <code>div</code>s…</p>
    <div class="sidenote">
    <p>I get a weird feeling in my stomach when the size of my code
    scales with the size of the output, but hey, HTML is not a
    programming language, so it’s fine, <small>right?</small></p>
    </div>
    <p>Ok <code>400i&lt;div&gt;&lt;/div&gt;&lt;CR&gt;&lt;Esc&gt;</code>
    done.</p>
    <div class="sidenote">
    <p>vim btw.</p>
    </div>
    <p>We’re gonna need some way to identify them to be able to
    calculate their colors later. That’s where <span
    class="rainbow">variables</span> come in. Let’s assign them their
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math>
    coordinates (starting with
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math>
    for the top left). Basically:</p>
    <div class="sourceCode" id="cb1"><pre
    class="sourceCode html"><code class="sourceCode html"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">div</span><span class="ot"> style</span><span class="op">=</span><span class="st">&quot;--x:1; --y:1;&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">div</span><span class="dt">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">div</span><span class="ot"> style</span><span class="op">=</span><span class="st">&quot;--x:2; --y:1;&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">div</span><span class="dt">&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">div</span><span class="ot"> style</span><span class="op">=</span><span class="st">&quot;--x:3; --y:1;&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">div</span><span class="dt">&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
    <p>I’m sure you could come up with a clever vim macro to do this but
    we’re gonna use python for code generation later any way so might as
    well…</p>
    <div class="sourceCode" id="cb2"><pre
    class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>rows, cols <span class="op">=</span> <span class="dv">20</span>, <span class="dv">20</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, rows <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, cols <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;&lt;div style=</span><span class="ch">\&quot;</span><span class="ss">--x:</span><span class="sc">{</span>x<span class="sc">}</span><span class="ss">; --y:</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">;</span><span class="ch">\&quot;</span><span class="ss">&gt;&lt;/div&gt;&quot;</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span></code></pre></div>
    <p>We also want to display them in a
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi>x</mi><mn>20</mn></mrow><annotation encoding="application/x-tex">20x20</annotation></semantics></math>
    grid. So let’s wrap everything in a
    <code>&lt;div id="mandelbrot&gt;...&lt;/div&gt;</code>.</p>
    <div class="sourceCode" id="cb3"><pre
    class="sourceCode css"><code class="sourceCode css"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="in">:root</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">--s</span><span class="ch">:</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#mandelbrot</span> {</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">display</span><span class="ch">:</span> <span class="dv">grid</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">grid-template-columns</span><span class="ch">:</span> <span class="fu">repeat(var(</span><span class="va">--s</span><span class="fu">)</span><span class="op">,</span> <span class="dv">30</span><span class="dt">px</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">grid-auto-rows</span><span class="ch">:</span> <span class="dv">30</span><span class="dt">px</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
    <p>Notice we use a variable for the grid size as we’re going to use
    this value in calculations later.</p>
    <p>To see variables in action let’s use our grid to display a simple
    pattern. For that we’ll need another key CSS feature – the <span
    class="rainbow">calc</span> function.</p>
    <div class="sourceCode" id="cb4"><pre
    class="sourceCode css"><code class="sourceCode css"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#mandelbrot</span> div {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">background-color</span><span class="ch">:</span> <span class="fu">rgba(</span><span class="dv">255</span><span class="op">,</span> <span class="dv">255</span><span class="op">,</span> <span class="dv">255</span><span class="op">,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">calc(var(</span><span class="va">--x</span><span class="fu">)</span> <span class="op">*</span> <span class="fu">var(</span><span class="va">--y</span><span class="fu">)</span> <span class="op">/</span> <span class="fu">pow(var(</span><span class="va">--s</span><span class="fu">)</span><span class="op">,</span> <span class="dv">2</span><span class="fu">)))</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
    <p>It’s <a
    href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc#examples">most
    often used</a> for its ability to combine different units. For
    example if you wanted an element to take up <code>100%</code> of the
    width but with some room for margins:
    <code>width: calc(100% - 80px);</code>. We’ll keep it simple though
    and just use it in one place – to compute the alpha values of our
    divs (as above).</p>
    <h2 id="the-first-iteration">The first iteration</h2>
    <p>Now for the core question – how do we actually compute the alpha
    values to make the Mandelbrot set appear?</p>
    <p>As I explained at the <a href="#what">beginning</a>, the usual
    approach is to count the number of iterations it takes the value to
    cross a certain threshold, but the thing is, it’s not easy to get
    CSS to do loops. So we’re gonna use a fixed number of iterations
    (you’ll see how in a minute) and then map the magnitude (distance
    from the origin) of a number to the alpha value of the corresponding
    <code>div</code>. Intuition: if after our fixed number of iterations
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">|</mo><mi>z</mi><mo stretchy="true" form="postfix">|</mo></mrow><annotation encoding="application/x-tex">|z|</annotation></semantics></math>
    will be large it means that it probably diverges quickly, so we’ll
    map it to a low alpha value and if
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">|</mo><mi>z</mi><mo stretchy="true" form="postfix">|</mo></mrow><annotation encoding="application/x-tex">|z|</annotation></semantics></math>
    is small it’s probably in the set <code>-&gt;</code> high alpha.</p>
    <p>Let’s start simple – just one iteration. Meaning we apply
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f(z) = z^2 + c</annotation></semantics></math>
    once starting with
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z = 0</annotation></semantics></math>
    and
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
    being the point represented by a specific <code>div</code>. Then we
    just need to get the magnitude:
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">|</mo><mi>z</mi><mo stretchy="true" form="postfix">|</mo></mrow><mn>2</mn></msup><mo>=</mo><mi>ℜ</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mi>ℑ</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">|z|^2 = \mathfrak{R}(z)^2 + \mathfrak{I}(z)^2</annotation></semantics></math>.</p>
    <p>We’ll use python to generate the <code>calc</code> call to use as
    the alpha value in CSS.</p>
    <div class="sourceCode" id="cb5"><pre
    class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sq(num):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f&quot;pow(</span><span class="sc">{</span>num<span class="sc">}</span><span class="ss">,2)&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> var(name):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f&quot;var(--</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">)&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> var(<span class="st">&#39;x&#39;</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> var(<span class="st">&#39;y&#39;</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gen_iters():</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f&quot;</span><span class="sc">{</span>sq(x)<span class="sc">}</span><span class="ss"> + </span><span class="sc">{</span>sq(y)<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(gen_iters())</span></code></pre></div>
    <p>This gets us <code>pow(var(--x),2) + pow(var(--y),2)</code> and
    pasting it for the alpha value of our <code>divs</code>’s
    <code>background-color</code>… All turned white.</p>
    <h2 id="fixing-the-problems">Fixing the problems</h2>
    <p>That’s unsuprising. The alpha in <code>rgba</code> is in range
    <code>0..1</code> and all our values are
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\ge 1</annotation></semantics></math>.
    It seems we have to apply some <span
    class="rainbow">mappings</span>.</p>
    <div class="sidenote">
    <p>Ok, no more rainbows…</p>
    </div>
    <p><strong>First</strong>: the Mandelbrot set tastes best when
    served in roughly
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mn>2.0</mn><mo>,</mo><mn>1.0</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mn>1.5</mn><mo>,</mo><mn>1.5</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[-2.0, 1.0] \times [-1.5, 1.5]</annotation></semantics></math>
    range. Right now we have
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mn>1.0</mn><mo>,</mo><mn>20.0</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1.0</mn><mo>,</mo><mn>20.0</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[1.0, 20.0] \times [1.0, 20.0]</annotation></semantics></math>
    so pretty far from ideal. As a general problem statement: we have a
    value
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">x \in [a, b]</annotation></semantics></math>
    and want to map it to be in
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[c, d]</annotation></semantics></math>.</p>
    <div class="sidenote">
    <p>This is a very common problem and I go through this process all
    the time.</p>
    </div>
    <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mn>1</mn><mi>.</mi><mspace width="0.222em"></mspace></mtd><mtd columnalign="left" style="text-align: left"><mi>x</mi><mo>−</mo><mi>a</mi></mtd><mtd columnalign="right" style="text-align: right"><mo>∈</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mn>2</mn><mi>.</mi><mspace width="0.222em"></mspace></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mi>x</mi><mo>−</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow></mfrac></mtd><mtd columnalign="right" style="text-align: right"><mo>∈</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mn>3</mn><mi>.</mi><mspace width="0.222em"></mspace></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mi>x</mi><mo>−</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo>−</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"><mo>∈</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>d</mi><mo>−</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mn>4</mn><mi>.</mi><mspace width="0.222em"></mspace></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mi>x</mi><mo>−</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo>−</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi></mtd><mtd columnalign="right" style="text-align: right"><mo>∈</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
    \begin{aligned}
    1.\ &amp; x - a &amp;\in &amp;[0, b-a] \\
    2.\ &amp; \frac{x-a}{b-a} &amp;\in &amp;[0, 1] \\
    3.\ &amp; \frac{x-a}{b-a}(d-c) &amp;\in &amp;[0, d-c] \\
    4.\ &amp; \frac{x-a}{b-a}(d-c) + c &amp;\in &amp;[c, d]
    \end{aligned}
    </annotation></semantics></math></p>
    <p>Voilà. Some python follows.</p>
    <div class="sourceCode" id="cb6"><pre
    class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> scale(x, a_to, b_to, a_from<span class="op">=</span><span class="dv">1</span>, b_from<span class="op">=</span><span class="dv">20</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Maps x that is in [a_from, b_from] to be in [a_to, b_to]</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f&quot;</span><span class="sc">{</span>a_to<span class="sc">}</span><span class="ss"> + (</span><span class="sc">{</span>x<span class="sc">}</span><span class="ss"> - </span><span class="sc">{</span>a_from<span class="sc">}</span><span class="ss">)*(</span><span class="sc">{</span>b_to<span class="sc">}</span><span class="ss"> - </span><span class="sc">{</span>a_to<span class="sc">}</span><span class="ss">)/(</span><span class="sc">{</span>b_from<span class="sc">}</span><span class="ss"> - </span><span class="sc">{</span>a_from<span class="sc">}</span><span class="ss">)&quot;</span></span></code></pre></div>
    <p>If you look closely you might notice that I put whitespace around
    <code>+</code> and <code>-</code> but not around <code>*</code> and
    <code>/</code>. The code we’ll generate later is going to get a
    little large so I wanted to at least save up on some whitespace. The
    spaces around <code>+</code> and <code>-</code> <a
    href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc-sum#description">are
    necessary</a> though as CSS uses them to distinguish from unary
    <code>+</code> and <code>-</code> (for example
    <code>calc(1-2)</code> is interpreted as <code>1</code> followed by
    <code>-2</code>).</p>
    <div class="sidenote">
    <p>Thanks to CSS’s <a
    href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_syntax/Error_handling">lovely
    error handling</a> this is a fact that I will remember for a long
    time.</p>
    </div>
    <p><strong>Second</strong>: Right now our outputted alpha values are
    in
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>∞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0, \infty)</annotation></semantics></math>
    and we need them to be in
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1.0</mn><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0, 1.0]</annotation></semantics></math>.
    Our previous method doesn’t digest infinities well so we need
    something different. There are many different approaches but I
    personally like the <a
    href="https://en.wikipedia.org/wiki/Sigmoid_function">sigmoid</a>.</p>
    <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mi>−</mi><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">
    \sigma(x) = \frac{1}{1+e^{-x}}
    </annotation></semantics></math></p>
    <p>It maps the nonnegative values to
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>0.5</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0.5, 1]</annotation></semantics></math>
    so we’ll take
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">2\sigma(-x)</annotation></semantics></math>
    which also makes it so that magnitudes close to
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
    (in the set) get an alpha close to
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
    (that’s just so it plays nicely with the site’s darkmode).</p>
    <p>Integrating it back to our little script.</p>
    <div class="sourceCode" id="cb7"><pre
    class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> scale(var(<span class="st">&#39;x&#39;</span>), var(<span class="st">&#39;xa&#39;</span>), var(<span class="st">&#39;xb&#39;</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> scale(var(<span class="st">&#39;y&#39;</span>), var(<span class="st">&#39;ya&#39;</span>), var(<span class="st">&#39;yb&#39;</span>))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># ...</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mapping(gen_iters(n)))</span></code></pre></div>
    <p>I thought it might be a good idea to keep the values as CSS
    variables for easy access.</p>
    <div class="sourceCode" id="cb8"><pre
    class="sourceCode css"><code class="sourceCode css"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#mandelbrot</span> {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* ... */</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">--xa</span><span class="ch">:</span> <span class="fu">var(</span><span class="dv">-2.0</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">--xb</span><span class="ch">:</span> <span class="fu">var(</span><span class="dv">1.0</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">--ya</span><span class="ch">:</span> <span class="fu">var(</span><span class="dv">-1.5</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">--yb</span><span class="ch">:</span> <span class="fu">var(</span><span class="dv">1.5</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
    <p>Nice! It seems that now all we need is…</p>
    <h2 id="more-iterations">More iterations</h2>
    <p>We want to apply
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f(z) = z^2 + c</annotation></semantics></math>
    a total of
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
    times (which I will denote
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f^{(n)}(z)</annotation></semantics></math>)
    starting at
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=0</annotation></semantics></math>
    and
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
    being the number represented by specific coordinates and then
    calculate
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">|</mo><mi>z</mi><mo stretchy="true" form="postfix">|</mo></mrow><mn>2</mn></msup><annotation encoding="application/x-tex">|z|^2</annotation></semantics></math>.
    To get
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">|</mo><mi>z</mi><mo stretchy="true" form="postfix">|</mo></mrow><mn>2</mn></msup><annotation encoding="application/x-tex">|z|^2</annotation></semantics></math>
    we need to compute the real and imaginary parts of
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f^{(n)}(z)</annotation></semantics></math>.</p>
    <p>Denote
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>y</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">c=x+yi</annotation></semantics></math>
    and say that after
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>
    iterations we got
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">f^{(n-1)}(z) = a+bi</annotation></semantics></math>
    for some
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">a, b \in \mathbb R</annotation></semantics></math>
    and so</p>
    <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mi>y</mi><mi>i</mi><mo>=</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>a</mi><mi>b</mi><mi>i</mi><mo>−</mo><msup><mi>b</mi><mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mi>y</mi><mi>i</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">f^{(n)}(z) = (a+bi)^2 + x+yi = a^2+2abi-b^2+x+yi.</annotation></semantics></math></p>
    <p>Grouping the real and imaginary parts we get</p>
    <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">|</mo><msup><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">|</mo></mrow><mn>2</mn></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>a</mi><mn>2</mn></msup><mo>−</mo><msup><mi>b</mi><mn>2</mn></msup><mo>+</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>a</mi><mi>b</mi><mo>+</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">|f^{(n)}(z)|^2 = (a^2-b^2+x)^2 + (2ab+y)^2.</annotation></semantics></math></p>
    <p>This equation translates literally to a simple recursive
    function:</p>
    <div class="sourceCode" id="cb9"><pre
    class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gen_iters(n):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">    |z|^2 after n iterations</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rec(num, i):</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> num</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        (re, im) <span class="op">=</span> rec(num, i<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="ss">f&quot;</span><span class="sc">{</span>sq(re)<span class="sc">}</span><span class="ss"> - </span><span class="sc">{</span>sq(im)<span class="sc">}</span><span class="ss"> + </span><span class="sc">{</span>x<span class="sc">}</span><span class="ss">&quot;</span>, <span class="ss">f&quot;2*(</span><span class="sc">{</span>re<span class="sc">}</span><span class="ss">)*(</span><span class="sc">{</span>im<span class="sc">}</span><span class="ss">) + </span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    (re, im) <span class="op">=</span> rec((x, y), n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f&quot;</span><span class="sc">{</span>sq(re)<span class="sc">}</span><span class="ss"> + </span><span class="sc">{</span>sq(im)<span class="sc">}</span><span class="ss">&quot;</span></span></code></pre></div>
    <p>I find that
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">n=6</annotation></semantics></math>
    works well, anything more might be too much.</p>
    <div class="sourceCode" id="cb10"><pre
    class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mapping(gen_iters(n)))</span></code></pre></div>
    <h2 id="zooming-in">Zooming in</h2>
    <p>The picture we got looks… ok but with only 400 pixels it’s hard
    to see much details. A cool effect we can add is zooming in on an
    area around the cursor.</p>
    <p>If you think about what it means to <em>zoom in</em> in our case
    it’s just changing the bounds (for example with changing
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mn>2.0</mn><mo>,</mo><mn>1.0</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mn>1.5</mn><mo>,</mo><mn>1.5</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mn>1.0</mn><mo>,</mo><mn>0.5</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mn>0.75</mn><mo>,</mo><mn>0.75</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[-2.0, 1.0]\times [-1.5, 1.5] \to [-1.0, 0.5] \times [-0.75, 0.75]</annotation></semantics></math>
    will zoom in <code>2x</code> around the origin).</p>
    <p>The plan is as follows:</p>
    <ol type="1">
    <li>Somehow get the cursor position</li>
    <li>Map it’s coordinates
    (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mn>20</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mn>20</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[1, 20] \times [1,20]</annotation></semantics></math>)
    to our coordinates
    (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mn>2.0</mn><mo>,</mo><mn>1.0</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mn>1.5</mn><mo>,</mo><mn>1.5</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[-2.0, 1.0] \times [-1.5, 1.5]</annotation></semantics></math>)</li>
    <li>Change the bounds to be
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">cursor_pos</mtext><mo>±</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\text{cursor_pos} \pm 0.5</annotation></semantics></math></li>
    </ol>
    <p>As for the first step we’ll use the CSS’s <a
    href="https://developer.mozilla.org/en-US/docs/Web/CSS/:has">:has()
    pseudoclass</a>. Let me show you the snippet first:</p>
    <div class="sourceCode" id="cb11"><pre
    class="sourceCode css"><code class="sourceCode css"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#mandelbrot</span><span class="in">:has(</span>div<span class="ex">[</span><span class="ss">style</span><span class="op">*=</span><span class="st">&quot;--x:3;&quot;</span><span class="ex">]</span><span class="in">:hover)</span> {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* </span><span class="al">TODO</span><span class="co">: change bounds */</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
    <p>We want to select the container <code>div</code> because that’s
    where the variables controlling the bounds live. The styles defined
    here will execute if our container <code>div</code> <em>has</em> a
    <code>div</code> with a style attribute <a
    href="https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors">containing</a>
    <code>"--x:3;"</code> that is currently <em>hovered</em>.</p>
    <p>Copying this for all other values of <code>--x</code> and
    <code>--y</code> we effectively know the cursor’s position.</p>
    <div class="sidenote">
    <p>This approach makes it harder to increase the size of our grid as
    we’ll also have to add move styles now. But at least it’s a linear
    relation and not quadratic as before…</p>
    </div>
    <p>Now for steps 2 and 3. We’ll use the same <a
    href="#fixing-the-problems">formula</a> to map the cursor position
    that is initially in
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mtext mathvariant="monospace">–𝚜</mtext><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mtext mathvariant="monospace">–𝚜</mtext><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[1, \texttt{--s}] \times [1, \texttt{--s}]</annotation></semantics></math>
    (<code>--s: 20;</code>) to be in
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtext mathvariant="monospace">–𝚍𝚎𝚏-𝚡𝚊</mtext><mo>,</mo><mtext mathvariant="monospace">–𝚍𝚎𝚏-𝚡𝚊</mtext><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtext mathvariant="monospace">–𝚍𝚎𝚏-𝚢𝚊</mtext><mo>,</mo><mtext mathvariant="monospace">–𝚍𝚎𝚏-𝚢𝚋</mtext><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[\texttt{--def-xa}, \texttt{--def-xa}] \times [\texttt{--def-ya}, \texttt{--def-yb}]</annotation></semantics></math>.
    Then just add
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>±</mi><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\pm 0.5</annotation></semantics></math>
    and we’re done.</p>
    <div class="sourceCode" id="cb12"><pre
    class="sourceCode css"><code class="sourceCode css"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#mandelbrot</span><span class="in">:has(</span>div<span class="ex">[</span><span class="ss">style</span><span class="op">*=</span><span class="st">&quot;--x:3;&quot;</span><span class="ex">]</span><span class="in">:hover)</span> {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">--xa</span><span class="ch">:</span> <span class="fu">calc(var(</span><span class="va">--def-xa</span><span class="fu">)</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">-</span> <span class="dv">1</span>)<span class="op">*</span>(<span class="fu">var(</span><span class="va">--def-xb</span><span class="fu">)</span> <span class="op">-</span> <span class="fu">var(</span><span class="va">--def-xa</span><span class="fu">)</span>)<span class="op">/</span>(<span class="fu">var(</span><span class="va">--s</span><span class="fu">)</span> <span class="op">-</span> <span class="dv">1</span>) <span class="op">-</span> <span class="dv">0.5</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">--xb</span><span class="ch">:</span> <span class="fu">calc(var(</span><span class="va">--def-xa</span><span class="fu">)</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">-</span> <span class="dv">1</span>)<span class="op">*</span>(<span class="fu">var(</span><span class="va">--def-xb</span><span class="fu">)</span> <span class="op">-</span> <span class="fu">var(</span><span class="va">--def-xa</span><span class="fu">)</span>)<span class="op">/</span>(<span class="fu">var(</span><span class="va">--s</span><span class="fu">)</span> <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> <span class="dv">0.5</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
    <p>Since we’re using those variables in our alpha calculation the
    image will change automatically.</p>
    <h2 id="the-end">The end</h2>
    <p>Check out the <a
    href="https://freeplacki.github.io/cssbrot">demo</a> and <a
    href="https://github.com/FreePlacki/cssbrot">source code</a>. If you
    have any improvements or spotted a mistake feel free to drop an <a
    href="https://github.com/FreePlacki/cssbrot/issues">issue</a>, same
    goes for this post <a
    href="https://github.com/FreePlacki/freeplacki.github.io/issues">here</a>.</p>
    <p>Here are some additional ideas to implement:</p>
    <ol type="1">
    <li>Right now we’re only doing grayscale, not much stopping you from
    using a different color pallete.</li>
    <li>It would be cool to be able to adjust the zoom level
    dynamically.</li>
    <li>We’re starting the itarations at
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=0</annotation></semantics></math>.
    Experiment with different values and maybe changing the starting
    point dynamically. Also try having a fixed
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
    with
    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
    representing the coordinates.</li>
    </ol>
</body>

</html>
